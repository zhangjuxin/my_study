## 前端项目持续集成

### CI持续集成  (Continuous integration)

``` 
在持续集成环境中，开发人员将会频繁的提交代码到主干。这些新提交在最终合并主线之前，都需要通过编译（webpack等工具）和自动化测试流进行验证。这样做是于之前持续集成过程中很重视自动化测试验证结果，以保障所有的提交在合并主干之后的质量问题，对可能出现的一些问题进行预警。

简单来说就是开发人员提交完代码，ci服务器自动拉去代码进行编译和自动化测试，完成之后发布到测试服务器上
```

### CD  持续交付(CONTINUOUS DELIVERY) 

```
持续交付就是讲我们的应用发布出去的过程。这个过程可以确保我们尽可能快的实现交付。这就意味着除了自动化测试，我们还需要有自动化的发布流，以及通过一
个按键就可以随时随地实现应用的部署上线。通过持续交付，您可以决定每天，每周，每两周发布一次，这完全可以根据自己的业务进行设置。但是，如果您真的希望体验持续交付的优势，就需要先进行小批量发布，尽快部署到生产线，以便在出现问题时方便进行故障排除。
```

### 持续部署(CONTINUOUS DEPLOYMENT) 

```
如果我们想更加深入一步的话，就是持续部署了。通过这个方式，任何修改通过了所有已有的工作流就会直接和客户见面。没有人为干预(没有一键部署按钮)，只有当一
个修改在工作流中构建失败才能阻止它部署到产品线。

持续部署是一个很优秀的方式，可以加速与客户的反馈循 环，但是会给团队带来压力，因为不再有“发布日”了。开发人员可以专注于构建软件，他们看到他们的修改在他们 完成工作后几分钟就上线了。基本上，当开发人员在主分 支中合并一个提交时，这个分支将被构建、测试，如果一切顺利，则部署到生产环境中。 

简单来说就是代码提交之后，如果测试通过直接发布，不需要人为的发布，这种一般使用在小公司，大公司不敢这么整。
```

### 持续部署平台：devosp

### 部署流程图

![部署流程图](/Users/apple/Desktop/yd-Study/专题三--前端工程化和持续集成/images/部署流程图.png)

1、trunk是主分支，是日常开发进行的地方。

2、branches是分支。一些阶段性的[release版本](https://www.baidu.com/s?wd=release版本&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，这些版本是可以继续进行开发和维护的，则放在branches目录中。又比如为不同用户客制化的版本，也可以放在分支中进行开发。

3、tags目录一般是只读的，这里存储阶段性的发布版本，只是作为一个里程碑的版本进行存档。

nodejs使用shelljs来操作shell

![CI流程机器图](/Users/apple/Desktop/yd-Study/专题三--前端工程化和持续集成/images/CI流程机器图.png)

### 资源定位

![资源定位](/Users/apple/Desktop/yd-Study/专题三--前端工程化和持续集成/images/资源定位.png)

上线的时候会给静态文件加一个md5的戳，例如上面，避免缓存。为什么要先上静态资源呢,比如HTML引的是a_1.css,如果先上了HTML，那么该HTML里面引的css文件名已经变成了a-2.css,那么会找不到该资源，先上线静态资源的话就可以找到，另一个好处是如果做回滚，那么直接回滚html就好了，静态资源的服务器上有上一版本的css,虽然占用了一点硬盘空间，但是无所谓

### 前端模块化

无模块时代  —相互依赖，全局变量

模块萌芽时代 立即执行函数   —解决了全局变量的问题

现代模块规范：commonjs amd cmd es6 module



为什么前端不能使用commonjs规范

> var math = require('math');
>
> 　　math.add(2, 3);

```
第二行math.add(2, 3)，在第一行require('math')之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。

这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于"假死"状态。

因此，浏览器端的模块，不能采用"同步加载"（synchronous），只能采用"异步加载"（asynchronous）。这就是AMD规范诞生的背景。
```

webpack为什么可以使用commonjs，webpack把所有引用的文件都合并到一起了，进行同步的引用模块

###  

### AMD(Asynchronous Module Definition) 

AMD是异步加载模块，判断文件是否加载完成，加载完成之后执行回调(所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。)

```
define(['dep1','dep2'],function(dep1,dep2){ 

//内部只能使⽤用指定的模块 return function(){}; 

}); 
```

目前[require.js](http://requirejs.org/)和[curl.js](https://github.com/cujojs/curl)。实现了这种规范

### CMD 

define(function(require,exports,module){ 

//此处如果需要加载某XX模块，可以引⼊入 var xx=require(‘XX’); 

}); 

AMD

CMD：使用正则匹配require里面的文件，先发出去请求，



 

