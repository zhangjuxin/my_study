# 函数式编程

## 前言

> 1.在node开发中 基本上需要大量的高阶函数

> 2.在写react的时候需要经常构建一些高阶组件 在需要写有关于redux的时候需要构建一些纯函数再去组合 包括这些库的源码也是

> 3.再平时写业务的时候 需要把复用的函数抽象出纯函数给团队去用

## 函数式编程基本概念

1. 函数式编程(Functional Programming)其实相对于计算机的历史 而言是一个非常古老的概念，甚至早于第一台计算机的诞生。函 数式编程的基础模型来源于 λ (Lambda x=>x*2)演算，而 λ 演算并 非设计于在计算机上执行，它是在 20 世纪三十年代引入的一套用 于研究函数定义、函数应用和递归的形式系统。 

2. 函数式编程不是用函数来编程，也不是传统的面向过程编程。主 旨在于将复杂的函数符合成简单的函数(计算理论，或者递归论， 或者拉姆达演算)。运算过程尽量写成一系列嵌套的函数调用 

3. JavaScript 是披着 C 外衣的 Lisp。

4. 真正的火热是随着React的高阶函数而逐步升温。 

## 特点

### 1.函数是"一等公民"

```js
 1.函数是一等公民。所谓”第一等公民”(first class)，指的是函数 与其他数据类型一样，处于平等地位，可以赋值给其他变量，也 可以作为参数，传入另一个函数，或者作为别的函数的返回值。
例子：
var print = function(i){ console.log(i);};
[1,2,3].forEach(print);

```

### 2.只用'表达式'不用'语句'

```js
"表达式"是一个单纯的运算过程，总是有返回值的；
"语句"是执行某种操作,没有返回值。
函数式编程的要求是只是用表达式，不使用语句，也就是说，每一步都是单纯的运算，而且都有返回值。

原因是函数式编程的开发冬季，一开始就是为了处理运算，不考虑对系统读写
当然，实际应用中，不做IO是不可能的，因此编程过程中，函数式编程只要求把io限制在最小
```

### 3.没有副作用

```
副作用指的是：函数内部与外部的互动(最典型的就是修改全局变量的值)，产生运算以外的其他结果。

函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。
```

### 4.不修改状态

```js
上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。
在其他类型的语言中，变量往往用来保存"状态"（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的"状态"。
```

### 5.引用透明

```js
指的是函数的运行不依赖于外部"外部变量或状态"，只依赖输入的参数，任何时候只要参数相同，函数的返回值总是相同。
```

## 函数式编程常用核心概念

### 纯函数

```js
对于相同的输入，永远得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态。

var xs = [1,2,3,4,5];
// Array.slice是纯函数，因为它没有副作用，对于固定的 输入，输出总是固定的
```

##### 优缺点

```js
//不纯的
var min = 18;
var checkage = age => age > min;
//纯的，这很函数式
var checkage = age => age > 18;

//在不纯的版本中，checkage不仅取决于age还有外部的变量min
//纯的把关键字18硬编码进了函数的内部，扩展性比较差，但是下面柯里化优雅的函数式可以解决
```

```js
 import _ from 'lodash';
var sin = _.memorize(x => Math.sin(x));
//第一次计算的时候会稍慢一点 var a = sin(1);
//第二次有了缓存，速度极快
var b = sin(1);

//纯函数不仅可以有效降低系统的复 杂度，还有很多很棒的特性，比如 可缓存性
```

##### 幂等性

幂等性是指执行函数无数次后还具有相同的效果

```js
Math.abs(Math.abs(-42))
```

### 偏应用函数

传递给函数一部分参数来调用他，让他返回一个函数去处理剩下的参数。

偏函数之所以偏，就在于其只能处理那些能与至少一个case语句匹配的输入，而不能处理所有可能的输入

 ```js

const partial = (f, ...args) => (...moreArgs) => f(...args, ...moreArgs);
const add3 = (a, b, c) => a + b + c;
// 偏应用 `2` 和 `3` 到 `add3` 给你一个单参数的函数 
const fivePlus = partial(add3, 2, 3);
fivePlus(4)
 ```

### 函数柯里化

柯里化通过偏应用函数实现

传递给函数一部分参数来调用他，让他返回一个函数去处理剩下的参数

```js
// 函数柯里化
var checkage = min => (age => age > min);
var check18 = checkage(18);//缓存了函数
check18(20);
//柯里化之前
function add (x,y){
  return x+y
}
add(1,2)//3
//柯里化之后
function addX(y){
  return function(x){
    return x+y;
}}
addX(2)(1);//3
//bind是一个经典的缓存
function foo(p1, p2) {
this.val = p1 + p2; }
var bar = foo.bind(null, “p1”); var baz = new bar("p2"); console.log(baz.val);

//事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数， 得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种 对参数的“缓存”，是一种非常高效的编写函数的方法:
```

### 函数组合

概念：纯函数以及如何他柯里化写出的洋葱代码a(h(c()))，为了解决函数嵌套的问题，我们需要用到组合函数

```js

const compose = (f, g) => (x => f(g(x)));
//取数组翻转后的第一个数
var first = arr => arr[0];
var reverse = arr => arr.reverse();
var last = compose(first, reverse);
last([1, 2, 3, 4, 5, ]);//5
```

### Point Free

参考链接：http://www.ruanyifeng.com/blog/2017/03/pointfree.html

1. 把一些**对象自带的方法**转化成纯函数，不要命名转瞬即逝的中间变量

2. 这个函数中，我们使用了str作为我们的中间变量，但这个中间变量除了让代码变得长了一点意外是毫无意义的。

   const f = str => str.toUpperCase().split(' ');

### 声明式与命令式代码

```
命令式代码的意思就是，我们通过编写一条又一条指令去让计算
机执行一些动作，这其中一般都会涉及到很多繁杂的细节。而声
明式就要优雅很多了，我们通过写表达式的方式来声明我们想干
什么，而不是通过一步一步的指示。
```

### 惰性求值



### 高阶函数

函数当参数就是，把传入的函数进行进一步的封装，返回一个新的函数就是高阶函数

```js
var add = function(a,b){ 
return a + b;
};

function math(func,array){ 
return func(array[0],array[1]);
} 

math(add,[1,2]); // 3 
/*它是一等公民
它已一个函数作为参数
已一个函数作为返回结果*/
```

### 尾调用优化 

指函数内部的**最后一个动作**是函数调用。 该调用的返回值， 直接返回给函数。。 函数调用自身， 称为递归。 如果尾调用自身， 就称为尾递归。 递归需要保存大 量的调用记录， 很容易发生栈溢出错误， 如果使用尾递归优化， 将递归变为循 环， 那么只需要保存一个调用记录， 这样就不会发生栈溢出错误了。*

```js
*// 不是尾递归，无法优化 斐波那契数列*

function factorial(n) {

   if (n === 1) return 1;

    return n * factorial(n - 1);

//这个函数最后一步还进行了n*的操作，所以不是尾递归，只能是递归，下面的函数最后一步是递归，所以是尾递归

}

function factorial(n, total) {

    if (n === 1) *return* total;

    return factorial(n - 1, n * total);

} *//ES6强制使用尾递归*
```

##### 传统递归

```js
function sum(n) {

​    *if* (n === 1) *return* 1;

​    *return* n + sum(n - 1);

}

sum(5)

​    (5 + sum(4))

​    (5 + (4 + sum(3)))

​    (5 + (4 + (3 + sum(2))))

​    (5 + (4 + (3 + (2 + sum(1)))))

		 (5 + (4 + (3 + (2 + 1))))

​    (5 + (4 + (3 + 3)))

​    (5 + (4 + 6))

​    (5 + 10)

15
```

> 普通递归时， 内存需要记录调用的堆栈所出 的深度和位置信息。 在最底层计算返回值， 再根据记录的信息， 跳回上一层级计算， 然后再跳回更高一层， 依次运行， 直到最 外层的调用函数。 在cpu计算和内存会消耗 很多， 而且当深度过大时， 会出现堆栈溢出



##### 尾递归优化版本

```js
function sum(x, total) {
    if (x === 1) {
        return x + total;
    }
    return sum(x - 1, x + total);
}
console.log(sum(5, 0));


sum(5, 0) 
sum(4, 5)
sum(3, 9)
sum(2, 12)
sum(1, 14)
15
//还是会有五个执行堆栈
//按道理尾递归调用调用栈永远都是更新当前的栈帧而已，这 样就完全避免了爆栈的危险。但是现如今的浏览器并未完全支持
//原因有二 1在引擎层面消除递归是一个隐式的行为，程序 员意识不到。2堆栈信息丢失了 开发者难已调试
//3.既然浏览器不支持我们可以把这些递归写成while~
```

> 整个计算过程是线性的，调用一次sum后会进入下一个栈，相关的信息跟随进入，不放在堆栈上保存，当计算完最后的值后，直接返回到最上层的sum(5,0),这样有效的防止堆栈的溢出。

### 闭包

如下例子，虽然外层的 makePowerFn 函数执行完毕，栈上的调用 帧被释放，但是堆上的作用域并不被释放，因此 power 依旧可以 被 powerFn 函数访问，这样就形成了闭包 

```js

//如下例子，虽然外层的 makePowerFn 函数执行完毕，栈上的调用 帧被释放，但是堆上的作用域并不被释放，因此 power 依旧可以 被 powerFn 函数访问，这样就形成了闭包
   function makePowerFn(power) { 
function powerFn(base) {
  return Math.pow(base, power); }
return powerFn; }
var square = makePowerFn(2); square(3); // 9
```

闭包是什么：

缓存了上下文的当前执行环境的词法作用域

console.trace()可以打印调用帧



函子相关内容：http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html